<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
	PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
	"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="gov.alaska.dggs.igneous.Audit">

	<insert id="insertGroup" useGeneratedKeys="true" keyColumn="audit_group_id" keyProperty="id">
		INSERT INTO audit_group (remark) VALUES (#{remark})
	</insert>


	<insert id="insert" useGeneratedKeys="true" keyColumn="audit_id" keyProperty="id">
		INSERT INTO audit (audit_group_id, barcode)
		VALUES (#{group.id}, #{barcode})
	</insert>

	<!--
		The whole barcode comparison wierdness in the functions below is a
		product of the fact that some barcodes are entered incorrectly in the
		database. If you scan such barcodes, they'll return "00001283", but
		will be entered in the database (and printed on the label) as
		"GMC-00001283"
	-->

	<!--
		This function prints summary details on problems with an audit
		for a range. It's only appropriate if we're assuming each
		audit_group in the date range is a discrete container.

		Forgive me for how bad this code is. I did try to make it as
		straight-forward as possible. The root "from" clause is just
		pulling a list of all audit_groups in the provided date range,
		with whatever the majority of the linked database entries think
		is the container. This container becomes the expected container
		for all the subqueries. I really wish I could use a FULL JOIN,
		but postgresql doesn't do FULL JOINs unless they're hashable
		or mergeable (As of Postgresql 9.3), which means the goofy crap
		with the barcodes prevents making this monster slightly more readable.
	-->
	<select id="getReportByDate" resultSetType="FORWARD_ONLY" parameterType="map" resultType="HashMap">
		SELECT qag.audit_group_id, qag.remark, qag.container_id,
			qag.path_cache AS path, dp.duplicates, nm.no_match,
			ws.wrong_shelf,
			<!--
				calculate the difference between the total number of barcodes
				in this group, and the expected number of barcodes in the 
				assumed container
			-->
			ABS(COALESCE(agc.cnt,0) - COALESCE(cc.cnt,0)) AS difference
		FROM (
			<!--
				Query all audit groups, find matching barcodes in inventory,
				pair them up to find distinct containers. Count said 
				containers and determine which is the highest, select
				only one (the highest count) for each audit_group and
				spit that out. Also, filter by date and path_cache
				as necessary.
			-->
			SELECT DISTINCT ON (audit_group_id)
				q.audit_group_id, q.remark, c.container_id, c.path_cache,
				COUNT(c.container_id) AS container_count
			FROM (
				SELECT DISTINCT a.audit_group_id, ag.remark, i.container_id,
					COALESCE(i.barcode, i.alt_barcode) AS barcode
				FROM audit AS a
				JOIN audit_group AS ag
					ON ag.audit_group_id = a.audit_group_id
				LEFT OUTER JOIN inventory AS i ON (
					a.barcode = i.barcode
					OR a.barcode = i.alt_barcode
					OR ('GMC-' || a.barcode) = i.barcode
				) AND i.active = true
				WHERE ag.create_date BETWEEN
					#{start}::timestamp AND #{end}::timestamp
			) AS q
			LEFT OUTER JOIN container AS c ON c.container_id = q.container_id
			<if test="path != null">
			WHERE c.path_cache ILIKE #{path}
			</if>
			GROUP BY q.audit_group_id, q.remark, c.container_id
			ORDER BY q.audit_group_id, container_count DESC
		) AS qag
		LEFT OUTER JOIN (
			<!-- Count duplicates for each audit group -->
			SELECT q.audit_group_id, COUNT(*) AS duplicates
			FROM (
				SELECT a.audit_group_id, a.barcode, COUNT(*)
				FROM audit AS a
				GROUP BY a.audit_group_id, a.barcode
				HAVING COUNT(*) > 1
				ORDER BY audit_group_id, barcode
			) AS q
			GROUP BY audit_group_id
		) AS dp ON dp.audit_group_id = qag.audit_group_id
		LEFT OUTER JOIN (
			<!--
				Count the number of barcodes that couldn't be matched
				for each group
			-->
			SELECT a.audit_group_id, COUNT(*) AS no_match
			FROM audit AS a
			LEFT OUTER JOIN inventory AS i ON (
				a.barcode = i.barcode
				OR a.barcode = i.alt_barcode
				OR ('GMC-' || a.barcode) = i.barcode
			) AND i.active = true
			WHERE i.inventory_id IS NULL
			GROUP BY a.audit_group_id
		) AS nm ON nm.audit_group_id = qag.audit_group_id
		LEFT OUTER JOIN (
			<!-- Count the number of distinct container_ids in each group -->
			SELECT audit_group_id,
				COUNT(container_id) AS wrong_shelf
			FROM (
				SELECT a.audit_group_id, i.container_id, COUNT(*)
				FROM audit AS a
				JOIN inventory AS i ON (
					a.barcode = i.barcode
					OR a.barcode = i.alt_barcode
					OR ('GMC-' || a.barcode) = i.barcode
				) AND i.active = true
				GROUP BY a.audit_group_id, i.container_id
			) AS q
			GROUP BY audit_group_id
			HAVING COUNT(container_id) > 1
		) AS ws ON ws.audit_group_id = qag.audit_group_id
		LEFT OUTER JOIN (
			<!-- Count the total number of barcodes in this each group -->
			SELECT audit_group_id, COUNT(barcode) AS cnt
			FROM audit
			GROUP BY audit_group_id
		) agc ON agc.audit_group_id = qag.audit_group_id
		LEFT OUTER JOIN (
			<!-- Count the total number of distinct barcodes in each container -->
			SELECT container_id, COUNT(barcode) AS cnt
			FROM (
				SELECT DISTINCT container_id,
					COALESCE(barcode, alt_barcode) AS barcode
				FROM inventory
			) AS q
			GROUP BY container_id
		) AS cc ON cc.container_id = qag.container_id
		ORDER BY qag.path_cache
	</select>


	<!--
		This function returns details on the results of a test from
		getReportByDate. It should return a scanned barcode, the barcode
		found in the database, and the container path. If these values
		are null, they're not found. If the container_id doesn't match the
		provided container_id, it was found in the wrong location.

		A sort is done based on the container_id, against the container_id
		specified using a DISTINCT so that if a box exists in multiple locations
		it only shows us the location we specified. The distinct is performed
		against the barcode (or the audit_id) in case there's multiple
		entries in the database for that barcode.
	-->
	<select id="getReportDetail" resultSetType="FORWARD_ONLY" parameterType="map" resultType="HashMap">
		SELECT * FROM ((
			SELECT DISTINCT ON(a.audit_id)
				a.barcode AS s_barcode,
				COALESCE(i.barcode, i.alt_barcode) AS i_barcode,
				c.container_id,
				c.path_cache AS path
			FROM audit AS a
			LEFT OUTER JOIN inventory AS i ON (
				a.barcode = i.barcode
				OR a.barcode = i.alt_barcode
				OR ('GMC-' || a.barcode) = i.barcode
			)
			LEFT OUTER JOIN container AS c ON c.container_id = i.container_id
			WHERE a.audit_group_id = #{audit_group_id}
			ORDER BY a.audit_id
			<if test="container_id != null">
				, i.container_id = #{container_id} DESC
			</if>
		) UNION (
			SELECT DISTINCT ON(i.barcode, i.alt_barcode)
				a.barcode AS s_barcode,
				COALESCE(i.barcode, i.alt_barcode) AS i_barcode,
				c.container_id,
				c.path_cache AS path
			FROM inventory AS i
			LEFT OUTER JOIN audit AS a ON (
				(
					a.barcode = i.barcode
					OR a.barcode = i.alt_barcode
					OR ('GMC-' || a.barcode) = i.barcode
				) AND a.audit_group_id = #{audit_group_id}
			)
			LEFT OUTER JOIN container AS c ON c.container_id = i.container_id
			<if test="container_id != null">
			WHERE i.container_id = #{container_id}
			</if>
		)) AS q ORDER BY s_barcode, i_barcode
	</select>
</mapper>
